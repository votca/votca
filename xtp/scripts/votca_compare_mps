#!/usr/bin/env python3
"""
compare_mps.py â€” compare VOTCA-XTP .mps text outputs with numeric tolerances.

Usage:
  python compare_mps.py ref.mps out.mps
  python compare_mps.py ref.mps out.mps --atol 1e-10 --rtol 1e-8
  python compare_mps.py ref.mps out.mps --no-ignore-comments

Exit codes:
  0 match, 1 mismatch, 2 parse error / IO error
"""

from __future__ import annotations

import argparse
import math
import re
import sys
from dataclasses import dataclass
from typing import List, Optional, Tuple


SITE_RE = re.compile(
    r"^\s*(?P<elem>\S+)\s+"
    r"(?P<x>[+-]?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)\s+"
    r"(?P<y>[+-]?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)\s+"
    r"(?P<z>[+-]?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)\s+"
    r"Rank\s+(?P<rank>\d+)\s*$"
)

CHARGE_RE = re.compile(r"^\s*(?P<q>[+-]?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*$")
POL_RE = re.compile(r"^\s*P\s+(?P<p>[+-]?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*$")
UNITS_RE = re.compile(r"^\s*Units\s+(?P<unit>\S+)\s*$")


@dataclass
class Site:
    elem: str
    x: float
    y: float
    z: float
    rank: int
    charge: float
    polarizability: float


@dataclass
class MPS:
    unit: str
    sites: List[Site]


def isclose(a: float, b: float, atol: float, rtol: float) -> bool:
    return math.isclose(a, b, abs_tol=atol, rel_tol=rtol)


def parse_mps(path: str, ignore_comments: bool = True) -> MPS:
    try:
        with open(path, "r", encoding="utf-8", errors="replace") as f:
            raw_lines = f.readlines()
    except OSError as e:
        raise RuntimeError(f"Failed to read {path}: {e}")

    # Strip trailing newlines, keep empty lines (we'll skip them)
    lines = [ln.rstrip("\n") for ln in raw_lines]

    # Optionally drop comment lines beginning with '!'
    if ignore_comments:
        lines = [ln for ln in lines if not ln.lstrip().startswith("!")]

    # Drop purely empty lines
    lines = [ln for ln in lines if ln.strip() != ""]

    unit: Optional[str] = None
    sites: List[Site] = []

    i = 0
    while i < len(lines):
        ln = lines[i]

        # Units line
        m = UNITS_RE.match(ln)
        if m:
            unit = m.group("unit")
            i += 1
            continue

        # Site record: site line + charge line + polarizability line
        m = SITE_RE.match(ln)
        if not m:
            raise ValueError(f"{path}: Unexpected line {i+1}: {ln!r}")

        elem = m.group("elem")
        x = float(m.group("x"))
        y = float(m.group("y"))
        z = float(m.group("z"))
        rank = int(m.group("rank"))

        if i + 2 >= len(lines):
            raise ValueError(f"{path}: Incomplete site block starting at line {i+1}")

        m_q = CHARGE_RE.match(lines[i + 1])
        if not m_q:
            raise ValueError(f"{path}: Expected charge line after site at line {i+1}, got: {lines[i+1]!r}")
        charge = float(m_q.group("q"))

        m_p = POL_RE.match(lines[i + 2])
        if not m_p:
            raise ValueError(f"{path}: Expected 'P <val>' line after charge at line {i+2}, got: {lines[i+2]!r}")
        pol = float(m_p.group("p"))

        sites.append(Site(elem=elem, x=x, y=y, z=z, rank=rank, charge=charge, polarizability=pol))
        i += 3

    if unit is None:
        raise ValueError(f"{path}: Missing 'Units ...' line")

    return MPS(unit=unit, sites=sites)


def compare_mps(a: MPS, b: MPS, atol: float, rtol: float, max_report: int) -> List[str]:
    diffs: List[str] = []

    if a.unit != b.unit:
        diffs.append(f"Units differ: A={a.unit!r} vs B={b.unit!r}")

    if len(a.sites) != len(b.sites):
        diffs.append(f"Number of sites differ: A={len(a.sites)} vs B={len(b.sites)}")
        # still compare up to min length to provide more context
    n = min(len(a.sites), len(b.sites))

    for idx in range(n):
        sa = a.sites[idx]
        sb = b.sites[idx]

        if sa.elem != sb.elem:
            diffs.append(f"[site {idx}] element differs: A={sa.elem!r} vs B={sb.elem!r}")

        if sa.rank != sb.rank:
            diffs.append(f"[site {idx}] rank differs: A={sa.rank} vs B={sb.rank}")

        # Coords
        for name, va, vb in (("x", sa.x, sb.x), ("y", sa.y, sb.y), ("z", sa.z, sb.z)):
            if not isclose(va, vb, atol, rtol):
                diffs.append(f"[site {idx}] {name} differs: A={va} vs B={vb} (atol={atol}, rtol={rtol})")

        # Charge / polarizability
        if not isclose(sa.charge, sb.charge, atol, rtol):
            diffs.append(f"[site {idx}] charge differs: A={sa.charge} vs B={sb.charge} (atol={atol}, rtol={rtol})")

        if not isclose(sa.polarizability, sb.polarizability, atol, rtol):
            diffs.append(f"[site {idx}] P differs: A={sa.polarizability} vs B={sb.polarizability} (atol={atol}, rtol={rtol})")

        if len(diffs) >= max_report:
            diffs.append(f"... more differences not shown (max_report={max_report})")
            break

    return diffs


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("file_a", help="reference .mps")
    ap.add_argument("file_b", help="output .mps")
    ap.add_argument("--atol", type=float, default=1e-12, help="absolute tolerance for numeric values")
    ap.add_argument("--rtol", type=float, default=1e-8, help="relative tolerance for numeric values")
    ap.add_argument("--max-report", type=int, default=50, help="max number of differences to print")
    ap.add_argument("--no-ignore-comments", action="store_true", help="do not ignore lines starting with '!'")
    args = ap.parse_args()

    try:
        a = parse_mps(args.file_a, ignore_comments=not args.no_ignore_comments)
        b = parse_mps(args.file_b, ignore_comments=not args.no_ignore_comments)
    except Exception as e:
        print(f"[compare_mps] ERROR: {e}", file=sys.stderr)
        return 2

    diffs = compare_mps(a, b, atol=args.atol, rtol=args.rtol, max_report=args.max_report)

    if diffs:
        print(f"[compare_mps] FAIL: {len(diffs)} issue(s) found")
        for d in diffs[:args.max_report]:
            print(" -", d)
        return 1

    print("[compare_mps] OK")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
