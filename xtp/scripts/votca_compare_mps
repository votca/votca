#!/usr/bin/env python3
"""
compare_mps.py â€” compare two MPS-like text files with numeric tolerances.

Features:
- Parse per-site scalar fields like "charge", "spin", etc.
- Compare site-by-site with rtol/atol.
- For selected fields (default: charge), allow a consistent global sign flip:
    accept if A ~= B OR A ~= -B (all sites), within tolerances.

This is useful when the representation has a gauge/sign ambiguity across platforms.

Usage:
  python compare_mps.py ref.mps out.mps
  python compare_mps.py ref.mps out.mps --sign-field charge --sign-field Trdipole
  python compare_mps.py ref.mps out.mps --atol 1e-10 --rtol 1e-8
"""

from __future__ import annotations

import argparse
import re
import sys
from dataclasses import dataclass
from typing import Dict, List, Tuple, Optional

import numpy as np


@dataclass
class Issue:
    msg: str


SITE_RE = re.compile(r"^\s*\[?\s*site\s+(\d+)\s*\]?\s*$", re.IGNORECASE)
# Matches: "charge: -0.123", "charge = -0.123", "charge  -0.123"
KV_RE = re.compile(
    r"^\s*([A-Za-z_][A-Za-z0-9_\-]*)\s*(?::|=|\s)\s*([+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?)\s*$"
)


def parse_mps(path: str) -> Dict[int, Dict[str, float]]:
    """
    Very forgiving parser:
      - sites introduced by a line like: "site 0" or "[site 0]"
      - within a site: lines like "charge: 0.123" or "charge = 0.123"
    """
    sites: Dict[int, Dict[str, float]] = {}
    cur: Optional[int] = None

    with open(path, "r", encoding="utf-8", errors="replace") as f:
        for line in f:
            m = SITE_RE.match(line)
            if m:
                cur = int(m.group(1))
                sites.setdefault(cur, {})
                continue

            m = KV_RE.match(line)
            if m and cur is not None:
                key = m.group(1)
                val = float(m.group(2))
                sites[cur][key] = val

    return sites


def allclose(a: np.ndarray, b: np.ndarray, rtol: float, atol: float) -> np.ndarray:
    return np.isclose(a, b, rtol=rtol, atol=atol, equal_nan=True)


def compare_field_with_optional_sign(
    field: str,
    a_vals: np.ndarray,
    b_vals: np.ndarray,
    rtol: float,
    atol: float,
    allow_sign: bool,
) -> Tuple[bool, bool, np.ndarray]:
    """
    Returns:
      ok, used_sign_flip, ok_mask
    """
    ok_same = allclose(a_vals, b_vals, rtol, atol)
    if np.all(ok_same):
        return True, False, ok_same

    if allow_sign:
        ok_flip = allclose(a_vals, -b_vals, rtol, atol)
        if np.all(ok_flip):
            return True, True, ok_flip

        # Not fully OK; return the better mode to report mismatches meaningfully
        if np.count_nonzero(~ok_flip) < np.count_nonzero(~ok_same):
            return False, True, ok_flip
        return False, False, ok_same

    return False, False, ok_same


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("file_a")
    ap.add_argument("file_b")
    ap.add_argument("--rtol", type=float, default=1e-8)
    ap.add_argument("--atol", type=float, default=1e-12)
    ap.add_argument(
        "--sign-field",
        action="append",
        default=["charge"],  # default: charge has sign ambiguity in your reports
        help="Field name for which a global sign flip is allowed (repeatable). Default: charge",
    )
    ap.add_argument("--max-issues", type=int, default=200)
    args = ap.parse_args()

    sign_fields = set(args.sign_field or [])

    sites_a = parse_mps(args.file_a)
    sites_b = parse_mps(args.file_b)

    issues: List[Issue] = []

    idx_a = sorted(sites_a.keys())
    idx_b = sorted(sites_b.keys())
    if idx_a != idx_b:
        missing_a = sorted(set(idx_b) - set(idx_a))
        missing_b = sorted(set(idx_a) - set(idx_b))
        if missing_a:
            issues.append(Issue(f"site indices missing in A: {missing_a}"))
        if missing_b:
            issues.append(Issue(f"site indices missing in B: {missing_b}"))

    common_sites = sorted(set(idx_a) & set(idx_b))
    if not common_sites:
        print("[compare_mps] FAIL: no common sites found", file=sys.stderr)
        return 1

    # Determine which fields to compare: intersection across all common sites
    fields_common = None
    for i in common_sites:
        fa = set(sites_a[i].keys())
        fb = set(sites_b[i].keys())
        inter = fa & fb
        fields_common = inter if fields_common is None else (fields_common & inter)

    fields_common = sorted(fields_common or [])
    if not fields_common:
        issues.append(Issue("no common scalar fields found to compare"))
        fields_common = []

    # Compare each field across sites
    for field in fields_common:
        a_vals = np.array([sites_a[i][field] for i in common_sites], dtype=float)
        b_vals = np.array([sites_b[i][field] for i in common_sites], dtype=float)

        allow_sign = field in sign_fields
        ok, used_flip, ok_mask = compare_field_with_optional_sign(
            field, a_vals, b_vals, args.rtol, args.atol, allow_sign
        )

        if ok:
            continue

        # Report mismatches site-by-site
        for pos, site_idx in enumerate(common_sites):
            if ok_mask[pos]:
                continue
            aval = a_vals[pos]
            bval = (-b_vals[pos]) if used_flip else b_vals[pos]
            flip_note = " (after global sign flip)" if used_flip else ""
            issues.append(
                Issue(
                    f"[site {site_idx}] {field} differs{flip_note}: "
                    f"A={aval:.16g} vs B={bval:.16g} (atol={args.atol}, rtol={args.rtol})"
                )
            )
            if len(issues) >= args.max_issues:
                issues.append(Issue(f"... more issues not shown (max_issues={args.max_issues})"))
                break
        if len(issues) >= args.max_issues:
            break

    if issues:
        print(f"[compare_mps] FAIL: {len(issues)} issue(s) found")
        for it in issues:
            print(" - " + it.msg)
        return 1

    print("[compare_mps] OK: files match (within tolerances; sign-aware fields allowed)")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
