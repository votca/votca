#!/usr/bin/env python3
"""
compare_h5.py — semantic HDF5 comparator for unit tests.

Usage:
  python compare_h5.py ref.h5 out.h5
  python compare_h5.py ref.h5 out.h5 --rtol 1e-8 --atol 1e-12 --ignore-attr XTPVersion
  python compare_h5.py ref.h5 out.h5 --ignore-path /metadata --ignore-path /frame_0/volatile

Exit code:
  0 if equivalent (within tolerances / ignore rules), 1 otherwise.
"""

from __future__ import annotations

import argparse
import math
import sys
from dataclasses import dataclass
from typing import Iterable, List, Optional, Set, Tuple

import h5py
import numpy as np


@dataclass
class Diff:
    path: str
    kind: str
    message: str


def is_float_dtype(dtype: np.dtype) -> bool:
    return np.issubdtype(dtype, np.floating)


def is_complex_dtype(dtype: np.dtype) -> bool:
    return np.issubdtype(dtype, np.complexfloating)


def normalize_scalar(x):
    # Convert numpy scalars to Python scalars for printing
    if isinstance(x, np.generic):
        return x.item()
    return x


def should_ignore_path(path: str, ignore_paths: Iterable[str]) -> bool:
    # Ignore exact match or subtree ignore
    for p in ignore_paths:
        if path == p or path.startswith(p.rstrip("/") + "/"):
            return True
    return False


def compare_attrs(
    a_obj, b_obj, path: str, diffs: List[Diff], ignore_attrs: Set[str]
) -> None:
    a_keys = set(a_obj.attrs.keys())
    b_keys = set(b_obj.attrs.keys())

    a_keys_eff = {k for k in a_keys if k not in ignore_attrs}
    b_keys_eff = {k for k in b_keys if k not in ignore_attrs}

    for k in sorted(a_keys_eff - b_keys_eff):
        diffs.append(Diff(path, "attr_missing_in_b", f"Attribute '{k}' exists in A but not B"))
    for k in sorted(b_keys_eff - a_keys_eff):
        diffs.append(Diff(path, "attr_missing_in_a", f"Attribute '{k}' exists in B but not A"))

    for k in sorted(a_keys_eff & b_keys_eff):
        av = a_obj.attrs.get(k)
        bv = b_obj.attrs.get(k)

        # h5py may return bytes for fixed-length strings
        if isinstance(av, (bytes, np.bytes_)):
            av = av.decode(errors="replace")
        if isinstance(bv, (bytes, np.bytes_)):
            bv = bv.decode(errors="replace")

        # Compare arrays/scalars robustly
        try:
            if isinstance(av, np.ndarray) or isinstance(bv, np.ndarray):
                av_arr = np.array(av)
                bv_arr = np.array(bv)
                if av_arr.shape != bv_arr.shape or av_arr.dtype != bv_arr.dtype:
                    diffs.append(
                        Diff(path, "attr_dtype_shape",
                             f"Attribute '{k}' differs in dtype/shape: "
                             f"A {av_arr.dtype}{av_arr.shape} vs B {bv_arr.dtype}{bv_arr.shape}")
                    )
                else:
                    if not np.array_equal(av_arr, bv_arr):
                        diffs.append(
                            Diff(path, "attr_value",
                                 f"Attribute '{k}' differs: A={av_arr} vs B={bv_arr}")
                        )
            else:
                if av != bv:
                    diffs.append(
                        Diff(path, "attr_value",
                             f"Attribute '{k}' differs: A={normalize_scalar(av)} vs B={normalize_scalar(bv)}")
                    )
        except Exception as e:
            diffs.append(Diff(path, "attr_compare_error", f"Attribute '{k}' compare error: {e}"))


def compare_datasets(
    a_ds: h5py.Dataset,
    b_ds: h5py.Dataset,
    path: str,
    diffs: List[Diff],
    rtol: float,
    atol: float,
    max_report: int,
) -> None:
    if a_ds.shape != b_ds.shape:
        diffs.append(Diff(path, "shape", f"Shape differs: A {a_ds.shape} vs B {b_ds.shape}"))
        return

    if a_ds.dtype != b_ds.dtype:
        # For portability, dtype metadata may differ even if values are representable.
        diffs.append(Diff(path, "dtype", f"Dtype differs: A {a_ds.dtype} vs B {b_ds.dtype}"))
        # We still attempt value compare when possible.

    # Read data
    try:
        a = a_ds[...]
        b = b_ds[...]
    except Exception as e:
        diffs.append(Diff(path, "read_error", f"Failed to read dataset: {e}"))
        return

    # For variable-length strings, object dtype, etc.
    if a.dtype.kind in ("O", "S", "U") or b.dtype.kind in ("O", "S", "U"):
        # Normalize bytes to str for consistent compare
        def norm_str(x):
            if isinstance(x, (bytes, np.bytes_)):
                return x.decode(errors="replace")
            return x

        a_flat = np.array([norm_str(x) for x in np.ravel(a)], dtype=object)
        b_flat = np.array([norm_str(x) for x in np.ravel(b)], dtype=object)
        if a_flat.shape != b_flat.shape or not np.array_equal(a_flat, b_flat):
            # report first few mismatches
            mism = np.where(a_flat != b_flat)[0]
            if mism.size:
                for idx in mism[:max_report]:
                    diffs.append(Diff(
                        path, "value",
                        f"Mismatch at flat index {int(idx)}: A={a_flat[idx]!r} vs B={b_flat[idx]!r}"
                    ))
                if mism.size > max_report:
                    diffs.append(Diff(path, "value", f"... {mism.size - max_report} more mismatches"))
        return

    # Numeric compare
    if is_float_dtype(a.dtype) or is_float_dtype(b.dtype) or is_complex_dtype(a.dtype) or is_complex_dtype(b.dtype):
        # Handle NaNs consistently: NaN == NaN for regression testing
        equal = np.isclose(a, b, rtol=rtol, atol=atol, equal_nan=True)
        if not np.all(equal):
            mism = np.where(~equal)
            # Flatten mismatch indices for reporting
            coords = list(zip(*mism))
            for coord in coords[:max_report]:
                av = a[coord]
                bv = b[coord]
                diffs.append(Diff(
                    path, "value",
                    f"Mismatch at {coord}: A={normalize_scalar(av)} vs B={normalize_scalar(bv)} "
                    f"(rtol={rtol}, atol={atol})"
                ))
            if len(coords) > max_report:
                diffs.append(Diff(path, "value", f"... {len(coords) - max_report} more mismatches"))
    else:
        # Integers / bool / enums
        if not np.array_equal(a, b):
            mism = np.where(a != b)
            coords = list(zip(*mism))
            for coord in coords[:max_report]:
                diffs.append(Diff(
                    path, "value",
                    f"Mismatch at {coord}: A={normalize_scalar(a[coord])} vs B={normalize_scalar(b[coord])}"
                ))
            if len(coords) > max_report:
                diffs.append(Diff(path, "value", f"... {len(coords) - max_report} more mismatches"))


def walk_and_compare(
    a_file: h5py.File,
    b_file: h5py.File,
    ignore_paths: List[str],
    ignore_attrs: Set[str],
    rtol: float,
    atol: float,
    max_report: int,
) -> List[Diff]:
    diffs: List[Diff] = []

    def recurse(path: str) -> None:
        if should_ignore_path(path, ignore_paths):
            return

        if path not in a_file:
            diffs.append(Diff(path, "missing_in_a", "Path exists in B but not A"))
            return
        if path not in b_file:
            diffs.append(Diff(path, "missing_in_b", "Path exists in A but not B"))
            return

        a_obj = a_file[path]
        b_obj = b_file[path]

        # Type compare
        if type(a_obj) != type(b_obj):
            diffs.append(Diff(path, "type", f"Type differs: A {type(a_obj)} vs B {type(b_obj)}"))
            return

        # Attributes
        compare_attrs(a_obj, b_obj, path, diffs, ignore_attrs)

        if isinstance(a_obj, h5py.Group):
            a_keys = set(a_obj.keys())
            b_keys = set(b_obj.keys())

            for k in sorted(a_keys - b_keys):
                child = f"{path.rstrip('/')}/{k}" if path != "/" else f"/{k}"
                if not should_ignore_path(child, ignore_paths):
                    diffs.append(Diff(path, "member_missing_in_b", f"Member '{k}' exists in A but not B"))
            for k in sorted(b_keys - a_keys):
                child = f"{path.rstrip('/')}/{k}" if path != "/" else f"/{k}"
                if not should_ignore_path(child, ignore_paths):
                    diffs.append(Diff(path, "member_missing_in_a", f"Member '{k}' exists in B but not A"))

            # Recurse common children
            for k in sorted(a_keys & b_keys):
                child = f"{path.rstrip('/')}/{k}" if path != "/" else f"/{k}"
                recurse(child)

        elif isinstance(a_obj, h5py.Dataset):
            compare_datasets(a_obj, b_obj, path, diffs, rtol, atol, max_report)

    recurse("/")
    return diffs


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("file_a", help="Reference / expected .h5")
    ap.add_argument("file_b", help="Output / actual .h5")
    ap.add_argument("--rtol", type=float, default=1e-8, help="Relative tolerance for float datasets")
    ap.add_argument("--atol", type=float, default=1e-12, help="Absolute tolerance for float datasets")
    ap.add_argument("--ignore-attr", action="append", default=[], help="Attribute name to ignore (repeatable)")
    ap.add_argument("--ignore-path", action="append", default=[], help="HDF5 path subtree to ignore (repeatable)")
    ap.add_argument("--max-report", type=int, default=10, help="Max mismatches to print per dataset/attr")
    args = ap.parse_args()

    ignore_attrs = set(args.ignore_attr)
    ignore_paths = list(args.ignore_path)

    # Sensible default for your case:
    # If you don’t specify, we still won’t auto-ignore anything.
    # But you can pass: --ignore-attr XTPVersion
    try:
        with h5py.File(args.file_a, "r") as fa, h5py.File(args.file_b, "r") as fb:
            diffs = walk_and_compare(
                fa, fb,
                ignore_paths=ignore_paths,
                ignore_attrs=ignore_attrs,
                rtol=args.rtol,
                atol=args.atol,
                max_report=args.max_report,
            )
    except OSError as e:
        print(f"[compare_h5] Failed to open files: {e}", file=sys.stderr)
        return 2

    if diffs:
        print(f"[compare_h5] FAIL: {len(diffs)} differences found")
        for d in diffs[:500]:
            print(f" - {d.path}: {d.kind}: {d.message}")
        if len(diffs) > 500:
            print(f" ... {len(diffs) - 500} more differences not shown")
        return 1

    print("[compare_h5] OK: files match (within tolerances / ignore rules)")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
