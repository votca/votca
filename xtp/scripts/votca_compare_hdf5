#!/usr/bin/env python3
"""
compare_h5.py — semantic HDF5 comparator for unit tests (dtype-agnostic),
with support for eigenvector-like sign/phase ambiguity, including:
  - .../eigenvectors, .../eigenvectors2, .../eigenvectors<N>
  - /QMdata/transition_dipoles/ind<N> (any N)

Also handles empty eigenvector datasets gracefully.

Robustness improvements:
- Uses dtype.names (not dtype.fields) to detect compound/structured arrays.
- If one side is detected as non-structured due to h5py/string quirks, it attempts
  a safe coercion into the other dtype before comparing field-by-field.

Features:
- Recursively compares groups/datasets/attributes
- Numeric tolerance (rtol/atol) for floats/complex, including inside compound dtypes
- Exact compare for ints/bools/strings unless overridden by numeric tolerance rules
- Ignore specific attribute names (e.g. XTPVersion)
- Ignore path subtrees (e.g. /metadata, /provenance)
- Special-case: eigenvector-like datasets match up to per-vector sign (real) / phase (complex)
  using a robust pivot-component alignment (more stable than dot-product sign).
- Friendly diff output with limited mismatch reporting

Usage:
  python compare_h5.py ref.h5 out.h5
  python compare_h5.py ref.h5 out.h5 --rtol 1e-7 --atol 2e-6 --ignore-attr XTPVersion
  python compare_h5.py ref.h5 out.h5 --ignore-path /provenance
"""

from __future__ import annotations

import argparse
import re
import sys
from dataclasses import dataclass
from typing import Any, Iterable, List, Set, Tuple

import h5py
import numpy as np


@dataclass
class Diff:
    path: str
    kind: str
    message: str


# ---------------------------
# Ignore rules
# ---------------------------

def should_ignore_path(path: str, ignore_paths: Iterable[str]) -> bool:
    for p in ignore_paths:
        p = p.rstrip("/")
        if not p:
            continue
        if path == p or path.startswith(p + "/"):
            return True
    return False


# ---------------------------
# Normalization helpers
# ---------------------------

def normalize_bytes(x: Any) -> Any:
    if isinstance(x, (bytes, np.bytes_)):
        return x.decode(errors="replace")
    return x


# ---------------------------
# Generic scalar compare
# ---------------------------

def compare_scalars_generic(av: Any, bv: Any, rtol: float, atol: float) -> bool:
    if isinstance(av, np.generic):
        av = av.item()
    if isinstance(bv, np.generic):
        bv = bv.item()

    av = normalize_bytes(av)
    bv = normalize_bytes(bv)

    if isinstance(av, (tuple, list)) and isinstance(bv, (tuple, list)) and len(av) == len(bv):
        return all(compare_scalars_generic(x, y, rtol, atol) for x, y in zip(av, bv))

    if isinstance(av, (int, np.integer)) and isinstance(bv, (int, np.integer)):
        return int(av) == int(bv)

    if isinstance(av, (float, np.floating)) and isinstance(bv, (float, np.floating)):
        return bool(np.isclose(av, bv, rtol=rtol, atol=atol, equal_nan=True))

    if isinstance(av, (complex, np.complexfloating)) and isinstance(bv, (complex, np.complexfloating)):
        avc = complex(av)
        bvc = complex(bv)
        return bool(
            np.isclose(avc.real, bvc.real, rtol=rtol, atol=atol, equal_nan=True)
            and np.isclose(avc.imag, bvc.imag, rtol=rtol, atol=atol, equal_nan=True)
        )

    return av == bv


# ---------------------------
# Reporting helpers
# ---------------------------

def _report_first_mismatches(
    diffs: List[Diff],
    path: str,
    kind: str,
    coords: List[Tuple[int, ...]],
    a: np.ndarray,
    b: np.ndarray,
    max_report: int,
    prefix: str = "",
) -> None:
    for coord in coords[:max_report]:
        diffs.append(Diff(path, kind, f"{prefix}Mismatch at {coord}: A={a[coord]!r} vs B={b[coord]!r}"))
    if len(coords) > max_report:
        diffs.append(Diff(path, kind, f"{prefix}... {len(coords) - max_report} more mismatches"))


# ---------------------------
# Eigenvector-like sign/phase alignment compare
# ---------------------------

def align_and_compare_eigenvectors(
    a: np.ndarray,
    b: np.ndarray,
    path: str,
    diffs: List[Diff],
    rtol: float,
    atol: float,
    max_report: int,
    eigen_axis: int = -1,
    component_axis: int = -2,
) -> None:
    """
    Compare eigenvector-like arrays up to an independent global sign (real) / phase (complex)
    per eigenvector.

    Default assumption:
      shape (..., vec_len, nvec)
        component_axis = -2 (vec_len)
        eigen_axis     = -1 (nvec)

    Robust alignment uses a pivot component (largest magnitude) rather than dot-product sign.

    Empty arrays are handled gracefully.
    """
    if a.shape != b.shape:
        diffs.append(Diff(path, "shape", f"Shape differs: A {a.shape} vs B {b.shape}"))
        return

    # Handle empty datasets safely
    if a.size == 0 or b.size == 0:
        if a.size != b.size:
            diffs.append(Diff(
                path, "value",
                f"One eigenvector-like dataset is empty and the other is not: A size={a.size} vs B size={b.size}"
            ))
        return

    if a.ndim < 2:
        ok = np.isclose(a, b, rtol=rtol, atol=atol, equal_nan=True)
        if not np.all(ok):
            idxs = np.argwhere(~ok)
            coords = [tuple(map(int, c)) for c in idxs]
            for coord in coords[:max_report]:
                diffs.append(Diff(
                    path, "value",
                    f"Mismatch at {coord}: A={a[coord]} vs B={b[coord]} (rtol={rtol}, atol={atol})"
                ))
        return

    eigen_axis = eigen_axis % a.ndim
    component_axis = component_axis % a.ndim
    if eigen_axis == component_axis:
        diffs.append(Diff(path, "compare_error", "eigen_axis and component_axis must be different"))
        return

    # Move component and eigen axes to the end: (..., vec_len, nvec)
    axes = list(range(a.ndim))
    for ax in sorted([component_axis, eigen_axis], reverse=True):
        axes.pop(ax)
    perm = axes + [component_axis, eigen_axis]

    a_perm = np.transpose(a, perm)
    b_perm = np.transpose(b, perm)

    vec_len = a_perm.shape[-2]
    nvec = a_perm.shape[-1]

    a2 = a_perm.reshape((-1, vec_len, nvec))
    b2 = b_perm.reshape((-1, vec_len, nvec))

    mismatches = 0
    for bi in range(a2.shape[0]):
        for j in range(nvec):
            aj = a2[bi, :, j]
            bj = b2[bi, :, j]

            # Pivot-based alignment
            abs_aj = np.abs(aj)
            abs_bj = np.abs(bj)
            pivot = int(np.argmax(abs_aj if abs_aj.max() >= abs_bj.max() else abs_bj))

            # If pivot is zero on both sides, fall back to dot alignment
            if (abs_aj[pivot] == 0) and (abs_bj[pivot] == 0):
                if np.iscomplexobj(aj) or np.iscomplexobj(bj):
                    dot = np.vdot(aj, bj)  # conj(aj)·bj
                    denom = abs(dot)
                    phase = dot / (denom if denom > 0 else 1.0)
                    bj_aligned = bj * phase.conjugate()
                else:
                    dot = float(np.dot(aj, bj))
                    sgn = -1.0 if dot < 0 else 1.0
                    bj_aligned = bj * sgn
            else:
                if np.iscomplexobj(aj) or np.iscomplexobj(bj):
                    ap = aj[pivot]
                    bp = bj[pivot]
                    if bp == 0:
                        bj_aligned = bj
                    else:
                        phase = ap / bp
                        phase = phase / (abs(phase) if abs(phase) > 0 else 1.0)  # pure phase
                        bj_aligned = bj * phase
                else:
                    sgn = -1.0 if (aj[pivot] * bj[pivot] < 0) else 1.0
                    bj_aligned = bj * sgn

            ok = np.isclose(aj, bj_aligned, rtol=rtol, atol=atol, equal_nan=True)
            if not np.all(ok):
                bad = np.argwhere(~ok).flatten()
                for k in bad[:max_report]:
                    diffs.append(Diff(
                        path, "value",
                        f"Eigenvector[{j}] mismatch at component {int(k)} (batch={bi}): "
                        f"A={aj[int(k)]} vs B_aligned={bj_aligned[int(k)]} (rtol={rtol}, atol={atol})"
                    ))
                    mismatches += 1
                    if mismatches >= max_report:
                        diffs.append(Diff(path, "value", f"... more mismatches not shown (max_report={max_report})"))
                        return


# ---------------------------
# Generic array compare
# ---------------------------

def compare_arrays_generic(
    a: np.ndarray,
    b: np.ndarray,
    path: str,
    diffs: List[Diff],
    rtol: float,
    atol: float,
    max_report: int,
) -> None:
    if a.shape != b.shape:
        diffs.append(Diff(path, "shape", f"Shape differs: A {a.shape} vs B {b.shape}"))
        return

    # Structured / compound dtype: compare field-by-field (robust detection via dtype.names)
    a_names = a.dtype.names
    b_names = b.dtype.names
    a_struct = a_names is not None
    b_struct = b_names is not None

    if a_struct or b_struct:
        # If one side isn't structured but the other is, try to coerce
        if a_struct and not b_struct:
            try:
                b = np.array(b, dtype=a.dtype)
                b_names = b.dtype.names
                b_struct = b_names is not None
            except Exception:
                diffs.append(Diff(path, "dtype",
                                  f"One side structured and other not (coercion failed): A {a.dtype} vs B {b.dtype}"))
                return

        if b_struct and not a_struct:
            try:
                a = np.array(a, dtype=b.dtype)
                a_names = a.dtype.names
                a_struct = a_names is not None
            except Exception:
                diffs.append(Diff(path, "dtype",
                                  f"One side structured and other not (coercion failed): A {a.dtype} vs B {b.dtype}"))
                return

        if (a.dtype.names is None) or (b.dtype.names is None):
            diffs.append(Diff(path, "dtype", f"Structured dtype detection mismatch: A {a.dtype} vs B {b.dtype}"))
            return

        if a.dtype.names != b.dtype.names:
            diffs.append(Diff(path, "dtype", f"Field names differ: A {a.dtype.names} vs B {b.dtype.names}"))
            return

        for name in a.dtype.names:
            try:
                compare_arrays_generic(a[name], b[name], f"{path}:{name}", diffs, rtol, atol, max_report)
            except Exception as e:
                diffs.append(Diff(f"{path}:{name}", "compare_error", f"Error comparing field '{name}': {e}"))
        return

    # Object dtype or vlen -> elementwise compare
    if a.dtype.kind == "O" or b.dtype.kind == "O":
        a_flat = a.ravel()
        b_flat = b.ravel()
        if a_flat.shape != b_flat.shape:
            diffs.append(Diff(path, "shape", f"Shape differs: A {a.shape} vs B {b.shape}"))
            return
        mismatches = []
        for i, (av, bv) in enumerate(zip(a_flat, b_flat)):
            if not compare_scalars_generic(av, bv, rtol, atol):
                mismatches.append((i,))
                if len(mismatches) >= max_report:
                    break
        if mismatches:
            for (i,) in mismatches:
                diffs.append(Diff(
                    path, "value",
                    f"Mismatch at flat index {i}: A={a_flat[i]!r} vs B={b_flat[i]!r} (rtol={rtol}, atol={atol})"
                ))
            if a_flat.size > max_report:
                diffs.append(Diff(path, "value", "… more mismatches may exist (report truncated)"))
        return

    # String/bytes arrays
    if a.dtype.kind in ("S", "U") or b.dtype.kind in ("S", "U"):
        def norm_arr(x: np.ndarray) -> np.ndarray:
            if x.dtype.kind == "S":
                return np.vectorize(lambda t: normalize_bytes(t))(x).astype(object)
            if x.dtype.kind == "U":
                return x.astype(object)
            return x.astype(object)

        a2 = norm_arr(a)
        b2 = norm_arr(b)
        if not np.array_equal(a2, b2):
            idxs = np.argwhere(a2 != b2)
            coords = [tuple(map(int, c)) for c in idxs]
            _report_first_mismatches(diffs, path, "value", coords, a2, b2, max_report)
        return

    # Numeric floats/complex: tolerance
    if (
        np.issubdtype(a.dtype, np.floating)
        or np.issubdtype(a.dtype, np.complexfloating)
        or np.issubdtype(b.dtype, np.floating)
        or np.issubdtype(b.dtype, np.complexfloating)
    ):
        ok = np.isclose(a, b, rtol=rtol, atol=atol, equal_nan=True)
        if not np.all(ok):
            idxs = np.argwhere(~ok)
            coords = [tuple(map(int, c)) for c in idxs]
            for coord in coords[:max_report]:
                diffs.append(Diff(
                    path, "value",
                    f"Mismatch at {coord}: A={a[coord]} vs B={b[coord]} (rtol={rtol}, atol={atol})"
                ))
            if len(coords) > max_report:
                diffs.append(Diff(path, "value", f"... {len(coords) - max_report} more mismatches"))
        return

    # Everything else: exact
    if not np.array_equal(a, b):
        idxs = np.argwhere(a != b)
        coords = [tuple(map(int, c)) for c in idxs]
        _report_first_mismatches(diffs, path, "value", coords, a, b, max_report)


# ---------------------------
# Attribute compare
# ---------------------------

def compare_attrs(
    a_obj: h5py.Dataset | h5py.Group,
    b_obj: h5py.Dataset | h5py.Group,
    path: str,
    diffs: List[Diff],
    ignore_attrs: Set[str],
    rtol: float,
    atol: float,
    max_report: int,
) -> None:
    a_keys = set(a_obj.attrs.keys())
    b_keys = set(b_obj.attrs.keys())

    a_keys_eff = {k for k in a_keys if k not in ignore_attrs}
    b_keys_eff = {k for k in b_keys if k not in ignore_attrs}

    for k in sorted(a_keys_eff - b_keys_eff):
        diffs.append(Diff(path, "attr_missing_in_b", f"Attribute '{k}' exists in A but not B"))
    for k in sorted(b_keys_eff - a_keys_eff):
        diffs.append(Diff(path, "attr_missing_in_a", f"Attribute '{k}' exists in B but not A"))

    for k in sorted(a_keys_eff & b_keys_eff):
        av = a_obj.attrs.get(k)
        bv = b_obj.attrs.get(k)

        try:
            avn = normalize_bytes(av)
            bvn = normalize_bytes(bv)

            if isinstance(avn, np.ndarray) or isinstance(bvn, np.ndarray):
                a_arr = np.array(avn)
                b_arr = np.array(bvn)
                compare_arrays_generic(a_arr, b_arr, f"{path}@{k}", diffs, rtol, atol, max_report)
            else:
                if not compare_scalars_generic(avn, bvn, rtol, atol):
                    diffs.append(Diff(path, "attr_value",
                                      f"Attribute '{k}' differs: A={avn!r} vs B={bvn!r}"))
        except Exception as e:
            diffs.append(Diff(path, "attr_compare_error", f"Attribute '{k}' compare error: {e}"))


# ---------------------------
# Dataset compare
# ---------------------------

_EIGENVEC_RE = re.compile(r"/eigenvectors\d*$")
_TDIPOLE_RE = re.compile(r"^/QMdata/transition_dipoles/ind\d+$")

def compare_dataset(
    a_ds: h5py.Dataset,
    b_ds: h5py.Dataset,
    path: str,
    diffs: List[Diff],
    rtol: float,
    atol: float,
    max_report: int,
) -> None:
    if a_ds.shape != b_ds.shape:
        diffs.append(Diff(path, "shape", f"Shape differs: A {a_ds.shape} vs B {b_ds.shape}"))
        return

    if a_ds.dtype != b_ds.dtype:
        diffs.append(Diff(path, "dtype", f"Dtype differs: A {a_ds.dtype} vs B {b_ds.dtype}"))

    try:
        a = a_ds[...]
        b = b_ds[...]
    except Exception as e:
        diffs.append(Diff(path, "read_error", f"Failed to read dataset: {e}"))
        return

    a_arr = np.array(a)
    b_arr = np.array(b)

    # Special-case: eigenvector-like datasets can differ by per-vector sign/phase
    if _EIGENVEC_RE.search(path):
        align_and_compare_eigenvectors(a_arr, b_arr, path, diffs, rtol, atol, max_report)
        return

    # Special-case: transition dipoles ind<N> can also flip sign (phase convention)
    if _TDIPOLE_RE.match(path):
        align_and_compare_eigenvectors(a_arr, b_arr, path, diffs, rtol, atol, max_report)
        return

    compare_arrays_generic(a_arr, b_arr, path, diffs, rtol, atol, max_report)


# ---------------------------
# Tree walk / compare
# ---------------------------

def walk_and_compare(
    a_file: h5py.File,
    b_file: h5py.File,
    ignore_paths: List[str],
    ignore_attrs: Set[str],
    rtol: float,
    atol: float,
    max_report: int,
    diffs: List[Diff],
) -> None:
    def recurse(path: str) -> None:
        if should_ignore_path(path, ignore_paths):
            return

        in_a = path in a_file
        in_b = path in b_file

        if not in_a and in_b:
            diffs.append(Diff(path, "missing_in_a", "Path exists in B but not A"))
            return
        if in_a and not in_b:
            diffs.append(Diff(path, "missing_in_b", "Path exists in A but not B"))
            return
        if not in_a and not in_b:
            return

        a_obj = a_file[path]
        b_obj = b_file[path]

        if isinstance(a_obj, h5py.Group) != isinstance(b_obj, h5py.Group):
            diffs.append(Diff(path, "type", f"Type differs: A {type(a_obj)} vs B {type(b_obj)}"))
            return

        compare_attrs(a_obj, b_obj, path, diffs, ignore_attrs, rtol, atol, max_report)

        if isinstance(a_obj, h5py.Group):
            a_children = set(a_obj.keys())
            b_children = set(b_obj.keys())

            for k in sorted(a_children - b_children):
                child = f"{path.rstrip('/')}/{k}" if path != "/" else f"/{k}"
                if not should_ignore_path(child, ignore_paths):
                    diffs.append(Diff(path, "member_missing_in_b", f"Member '{k}' exists in A but not B"))

            for k in sorted(b_children - a_children):
                child = f"{path.rstrip('/')}/{k}" if path != "/" else f"/{k}"
                if not should_ignore_path(child, ignore_paths):
                    diffs.append(Diff(path, "member_missing_in_a", f"Member '{k}' exists in B but not A"))

            for k in sorted(a_children & b_children):
                child = f"{path.rstrip('/')}/{k}" if path != "/" else f"/{k}"
                recurse(child)

        else:
            compare_dataset(a_obj, b_obj, path, diffs, rtol, atol, max_report)

    recurse("/")


# ---------------------------
# Main
# ---------------------------

def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("file_a", help="Reference / expected .h5")
    ap.add_argument("file_b", help="Output / actual .h5")

    ap.add_argument("--rtol", type=float, default=1e-8, help="Relative tolerance for float/complex values")
    ap.add_argument("--atol", type=float, default=1e-12, help="Absolute tolerance for float/complex values")

    ap.add_argument("--ignore-attr", action="append", default=[],
                    help="Attribute name to ignore (repeatable), e.g. --ignore-attr XTPVersion")
    ap.add_argument("--ignore-path", action="append", default=[],
                    help="HDF5 path subtree to ignore (repeatable), e.g. --ignore-path /metadata")

    ap.add_argument("--max-report", type=int, default=20,
                    help="Max mismatches to print per dataset/attr section")
    ap.add_argument("--max-diffs", type=int, default=500,
                    help="Max total diffs to print before truncating")
    args = ap.parse_args()

    ignore_attrs = set(args.ignore_attr)
    ignore_paths = list(args.ignore_path)

    diffs: List[Diff] = []
    try:
        with h5py.File(args.file_a, "r") as fa, h5py.File(args.file_b, "r") as fb:
            walk_and_compare(
                fa, fb,
                ignore_paths=ignore_paths,
                ignore_attrs=ignore_attrs,
                rtol=args.rtol,
                atol=args.atol,
                max_report=args.max_report,
                diffs=diffs,
            )
    except OSError as e:
        print(f"[compare_h5] ERROR opening files: {e}", file=sys.stderr)
        return 2

    if diffs:
        print(f"[compare_h5] FAIL: {len(diffs)} differences found")
        for d in diffs[:args.max_diffs]:
            print(f" - {d.path}: {d.kind}: {d.message}")
        if len(diffs) > args.max_diffs:
            print(f" ... {len(diffs) - args.max_diffs} more differences not shown")
        return 1

    print("[compare_h5] OK: files match (within tolerances / ignore rules / sign-phase alignment for eigenvector-like data)")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
